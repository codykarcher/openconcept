import numpy as np
from openmdao.api import ExplicitComponent
from openmdao.api import Group

class FuelCellSOFC(Group):
    """
    This is a model of a Solid Oxide Fuel Cell (SOFC).  It is primarily based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016), 
    beginning on page 216, with a few modifications.  It is a 1D model with a number of simplifying assumptions, but represents the highest 
    available fidelity without moving to CFD analysis.  The most critical assumption is that of j_L, or the limit current density, which sets 
    the shape of the voltage vs. current density curves.  This value should in theory be set by the cathode thickness, which is highly dependent 
    on the state of modern technology.

    Additionaly, the mass model here depends on two critical constants A and B, which are entirely empirical and should not be trusted for 
    work on real engineering applications.  At a minimum, we recommend studying the effects of varying these parameters.  

    There is an assumed DC-DC conversion step since most fuel cells are not designed to produce the desired output voltage.

    User should beware that locking in a ratedPower value is likely unwise, and this should be treated as a lower bound constraint, ie
    ratedPower >= someLowerBound.  This is because designing the cell for a higher rated power than necessary will increase the mass, but
    may also significantly improve operating efficiency at the design point.  Since weight impacts fuel burn by a log, and efficiency linearly,
    there will be some tradeoff here.  

    There are a number of exposed options, which we as the modelers expect will want to be varied by the end user.  However, there are a 
    number of hidden options in the self.setup function which also may be of interest to the expert user.

    Inputs
    ------
    pressure : float
        Operating pressure of the fuel cell.  This model does not account
        for a compressor to rais the operating pressure from ambient.
        (scalar, atmospheres)
    temperature : float
        Operating temperature of the fuel cell.
        (scalar, Kelvin)
    ratedPower : float
        Rated power of the fuel cell after DC-DC conversion
        (scalar, W)
    throttle : float
        Engine throttle. Scales current density based on the internally 
        computed maximum current density value.  Produces 100% of rated 
        power at throttle = 1.  Should be in range 0 to 1
        (vector, dimensionless)

    Outputs
    -------
    mdot_H2 : float
        Mass consumption of hydrogen, ie fuel flow
        (vector, kg/s)
    mdot_O2 : float
        Mass consumption of oxygen, sets inlet requirements
        (vector, kg/s)
    mdot_Air : float
        Mass consumption of air based on the mass fraction of oxygen
        (vector, kg/s) 
    eps_total : float
        Fuel cell efficiency
        (vector, dimensionless)
    power : float
        Electrical power generated by the fuel cell
        (vector, Watts)
    usablePower : float
        Power available after DC-DC conversion
        (vector, Watts)
    usableHeat : float
        Heat generated by the fuel cell and the DC-DC converter
        (vector, Watts)
    heat : float
        Heat generated by the fuel cell 
        (vector, Watts)

    Options
    -------
    num_nodes : int
        Number of analysis points to run (sets vec length; default 1)
    n_samples : int
        Number of samples used in finding the j_max value
        (default 1000)
    j_L : float
        Limit current density, primarily driven by the thickness of the
        cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)

    """

    def initialize(self):
        self.options.declare("num_nodes"   , default=1           , desc = "Number of flight/control conditions")
        self.options.declare("n_samples"   , default=1000        , desc = "Number of samples to take in finding j_max")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # # Likely to change:
        # self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        # self.options.declare("A_SOFC"      , default = 9e7       , desc = "Electrolyte constant [K/(ohm*m)]")
        
        # # May Change:
        # self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        # self.options.declare("DeltaG_act"  , default = 100e3     , desc = "Electrolyte activation energy [J/mol]")
        # self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        # self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        # self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        # self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # # Should not change
        # self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        # self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        # self.options.declare("x_O2d"       , default = 0.21      , desc = "Oxygen inlet mole fraction")

    def setup(self):
        hidden_options_dict = {
                                    "t_M"         : 20e-6,
                                    "A_SOFC"      : 9e7,
                                    "E_thermo"    : 1.06,
                                    "DeltaG_act"  : 100e3,
                                    "alpha"       : 0.5,
                                    "j0"          : 0.1,
                                    "eps"         : 0.4,
                                    "tau"         : 1.5,
                                    "R"           : 8.314,
                                    "F"           : 96485.34,
                                    "x_O2d"       : 0.21,
                              }

        jmax_dict     = {"n_samples":self.options["n_samples"],
                         "j_L":self.options["j_L"] } | hidden_options_dict

        sizing_dict   = {"j_L":self.options["j_L"], 
                         "A":self.options["A"], 
                         "B":self.options["B"], 
                         "eta_dcdc":self.options["eta_dcdc"]} | hidden_options_dict

        analysis_dict = {"num_nodes":self.options["num_nodes"],
                         "j_L":self.options["j_L"], 
                         "A":self.options["A"], 
                         "B":self.options["B"], 
                         "eta_dcdc":self.options["eta_dcdc"]} | hidden_options_dict

        self.add_subsystem("ComputeDiffusivity_O2N2", 
                           ComputeDiffusivity(medium1="O2", medium2="N2"), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("ComputeEpsThermo", 
                           ComputeEpsThermo(), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("computeJMax", 
                           ComputeJMax(**jmax_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("SOFCSizing", 
                           SOFCSizing(**sizing_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("SOFCAnalysis", 
                           SOFCAnalysis(**analysis_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])


class ComputeDiffusivity(ExplicitComponent):
    """
    This is a model for the binary diffusion coefficient based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016), page 173.
    It supports the media: H2, Air, N2, O2, CO, CO2, and H2O.  The model is dependent on temperature and pressure.

    Inputs
    ------
    pressure : float
        Ambient pressure
        (scalar, atmospheres)
    temperature : float
        Ambient temperature
        (scalar, Kelvin)

    Outputs
    -------
    diffusivity_O2N2 : float
        In this context, the model specifically outputs the binary diffusion coefficient for oxygen and nitrogen, though the model
        is capable of more general analysis using the options
        (scalar, m**2/s)

    Options
    -------
    medium1 : str
        The first medium
        (default "O2")
    medium2 : str
        The second medium
        (default "N2")

    """

    def initialize(self):
        self.options.declare("medium1", default="O2" , desc = "Diffusion Medium 1")
        self.options.declare("medium2", default="N2" , desc = "Diffusion Medium 2")
        
    def setup(self):
        self.add_input("pressure"    , units="atm" , desc = "Fuel cell pressure")
        self.add_input("temperature" , units="K"   , desc = "Fuel cell temperature")

        self.add_output("diffusivity_O2N2", units="m**2/s", desc = "Diffusivity")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        p = inputs["pressure"]
        T = inputs["temperature"]

        medium1 = self.options["medium1"]
        medium2 = self.options["medium2"]

        if medium1 not in ["H2","Air","N2","O2","CO","CO2","H2O"]:
            raise ValueError("Invalid Medium for Diffusion")

        if medium2 not in ["H2","Air","N2","O2","CO","CO2","H2O"]:
            raise ValueError("Invalid Medium for Diffusion")

        if 'H2O' not in [medium1, medium2]:
            a = 2.7445e-4
            b = 1.823
        else:
            a = 3.640e-4
            b = 2.334
        
        tbl = {}
        tbl['H2'] = {}
        tbl['H2']['M']  = 2.016
        tbl['H2']['Tc'] = 33.3
        tbl['H2']['pc'] = 12.80
        tbl['Air'] = {}
        tbl['Air']['M']  = 28.964
        tbl['Air']['Tc'] = 132.4
        tbl['Air']['pc'] = 37.0
        tbl['N2'] = {}
        tbl['N2']['M']  = 28.013
        tbl['N2']['Tc'] = 126.2
        tbl['N2']['pc'] = 33.5
        tbl['O2'] = {}
        tbl['O2']['M']  = 31.999
        tbl['O2']['Tc'] = 154.4
        tbl['O2']['pc'] = 49.7
        tbl['CO'] = {}
        tbl['CO']['M']  = 28.010
        tbl['CO']['Tc'] = 132.9
        tbl['CO']['pc'] = 34.5
        tbl['CO2'] = {}
        tbl['CO2']['M']  = 44.010
        tbl['CO2']['Tc'] = 304.2
        tbl['CO2']['pc'] = 72.8
        tbl['H2O'] = {}
        tbl['H2O']['M']  = 18.015
        tbl['H2O']['Tc'] = 647.3
        tbl['H2O']['pc'] = 217.5
        
        Tci = tbl[medium1]['Tc']
        Tcj = tbl[medium2]['Tc']
        pci = tbl[medium1]['pc']
        pcj = tbl[medium2]['pc']
        Mi  = tbl[medium1]['M']
        Mj  = tbl[medium2]['M']
        
        D_ij = (1/p) * a * (T/(Tci*Tcj)**0.5)**b * (pci*pcj)**(1/3) * (Tci*Tcj)**(5/12) * (1/Mi + 1/Mj)**0.5

        #formula is in cm**2/s and needs to be corrected
        D_ij/=10000

        outputs["diffusivity_O2N2"] = D_ij


class ComputeEpsThermo(ExplicitComponent):
    """
    This is a model for the maximum theoretical fuel cell efficiency based on the book "Fuel Cell Fundementals" 
    by O'Hayre et. al. (2016), Chapter 2.  

    Inputs
    ------
    temperature : float
        Ambient temperature
        (scalar, Kelvin)

    Outputs
    -------
    eps_thermo : float
        Max theoretical efficiency of the fuel cell
        (scalar, dimensionless)

    """

    def initialize(self):
        pass

    def setup(self):
        self.add_input("temperature", units="K", desc = "Fuel cell temperature")

        self.add_output("eps_thermo",  desc = "Max theoretical thermo efficiency")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        T = inputs["temperature"]
        # (kJ/mol)
        Delta_h0_H2O_g = -241.83
        Delta_h0_H2O_l = -285.83
        Delta_h0_H2    = 0.00
        Delta_h0_O2    = 0.00

        Delta_h0_g = Delta_h0_H2O_g - (Delta_h0_H2 + 0.5*Delta_h0_O2)
        Delta_h0_l = Delta_h0_H2O_l - (Delta_h0_H2 + 0.5*Delta_h0_O2)

        if T >= 373.15:
            # Reaction produces gaseous water
            Delta_h0 = Delta_h0_g
        else:
            # Reaction produces liquid water
            Delta_h0 = Delta_h0_l

        #(J/(mol*K))
        s0_H2O_g = 188.84
        s0_H2O_l = 69.95
        s0_H2    = 130.68
        s0_O2    = 205.00

        Delta_s0_g = s0_H2O_g - (s0_H2 + 0.5*s0_O2)
        Delta_s0_l = s0_H2O_l - (s0_H2 + 0.5*s0_O2)

        if T >= 373.15:
            # Reaction produces gaseous water
            Delta_s0 = Delta_s0_g
        else:
            # Reaction produces liquid water
            Delta_s0 = Delta_s0_l

        Delta_g = Delta_h0 - T*Delta_s0 / 1000 # need J to kJ correction

        # Delta_h_LHV = -241. # (kJ/mol), assumes gaseous water, do not use
        #  Would need to somehow extract the work from condensation, which is not realistic
        Delta_h_HHV = -285.83 # (kJ/mol), Assumes condensed water

        eps_thermo = Delta_g/Delta_h_HHV
        outputs["eps_thermo"] = eps_thermo


class ComputeJMax(ExplicitComponent):
    """
    This is a model for determining the current density that provides the maximum power output based on the book "Fuel Cell Fundementals" 
    by O'Hayre et. al. (2016).  It computes a Power vs. Current Density curve that is sampled at discrete intervals between 0 and j_L,
    which is set as an option.  The number of samples is also an option.  

    Inputs
    ------
    pressure : float
        Ambient pressure
        (scalar, atmospheres)
    temperature : float
        Ambient temperature
        (scalar, Kelvin)
    diffusivity_O2N2 : float
        Binary diffusion coefficient for oxygen and nitrogen, comes from previous model
        (scalar, m**2/s)
    eps_thermo : float
        Max theoretical efficiency of the fuel cell, comes from previous model
        (scalar, dimensionless)

    Outputs
    -------
    j_max : float
        Current density that produces the maximum power
        (scalar, A/cm**2)

    Options
    -------
    n_samples : int
        Number of samples used in finding the j_max value
        (default 1000)
    j_L : float
        Limit current density, primarily driven by the thickness of the cathode
        (default 2.0, A/cm**2)
    t_M : float
        Membrane thickness for the electrolyte passing material [m]
        (default 20e-6)
    A_SOFC : float
        Electrolyte constant, essentially the resistivity of the electrolyte material [K/(ohm*m)]
        (default  9e7)
    E_thermo     
        Thermodynamic voltage, theoretical value that probably should not change [V]
        ( default 1.06 )     
    DeltaG_act   
        Electrolyte activation energy [J/mol]
        ( default 100e3 )    
    alpha        
        Transfer coefficient, ranges from 0.2 to 0.5
        ( default 0.5 )      
    j0           
        Exchange current density [A/cm**2]
        ( default 0.1 )      
    eps          
        Porosity of the electrodes
        ( default 0.4 )      
    tau          
        Tortuosity of the electrodes, ranges from 1.5 to 10
        ( default 1.5 )      
    R            
        Gas constant [J/(mol*K)]
        ( default 8.314 )    
    F            
        Faraday constant [C/mol]
        ( default 96485.34 ) 
    x_O2d        
        Oxygen inlet mole fraction
        ( default 0.21 )    

    """
    def initialize(self):
        # Setup
        self.options.declare("n_samples"   , default = 300       , desc = "Number of samples to find j_max")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")

        # Likely to change:
        self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        self.options.declare("A_SOFC"      , default = 9e7       , desc = "Electrolyte constant [K/(ohm*m)]")
        
        # May Change:
        self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        self.options.declare("DeltaG_act"  , default = 100e3     , desc = "Electrolyte activation energy [J/mol]")
        self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # Should not change
        self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        self.options.declare("x_O2d"       , default = 0.21      , desc = "Oxygen inlet mole fraction")

    def setup(self):
        # self.add_input("ratedPower"       , units="W"      , desc = "Rated Power")
        self.add_input("pressure"         , units="atm"    , desc = "Fuel cell pressure")
        self.add_input("temperature"      , units="K"      , desc = "Fuel cell temperature")
        self.add_input("diffusivity_O2N2" , units="m**2/s" , desc = "Diffusivity of oxygen and nitrogen")
        self.add_input("eps_thermo"       ,                  desc = "Max theoretical thermo efficiency")

        self.add_output("j_max", units="A/cm**2", desc = "Fuel cell current density at max power")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        p          = inputs["pressure"]
        T          = inputs["temperature"]
        D_ij       = inputs["diffusivity_O2N2"]
        eps_thermo = inputs["eps_thermo"]

        j_L        = self.options["j_L"]
        t_M        = self.options["t_M"]
        A_SOFC     = self.options["A_SOFC"]
        E_thermo   = self.options["E_thermo"]
        DeltaG_act = self.options["DeltaG_act"]
        alpha      = self.options["alpha"]
        j0         = self.options["j0"]
        eps        = self.options["eps"]
        tau        = self.options["tau"]
        R          = self.options["R"]
        F          = self.options["F"]
        x_O2d      = self.options["x_O2d"]

        j_max = 0
        powerRate_prev = 0.0
        jarr = np.linspace(0,j_L,self.options["n_samples"])
        for j in jarr[1:]:
            eta_ohmic = j * 1e4 * (t_M * T) / (A_SOFC * np.exp(-DeltaG_act / (R*T)))

            p_atm = 101325   # Atmospheric pressure in Pa
            p_c = p * p_atm  # Convert cathode pressure to Pa

            D_eff_O2N2 = eps / tau * D_ij
            cr = x_O2d*p_c/ R/T
            t_C = 4 * F * D_eff_O2N2 / j_L * cr/10000
            f_j = j/j_L
            if j == 0:
                eta_cathode = 0
            elif f_j>=1:
                eta_cathode = E_thermo
            else:
                eta_cathode =  R * T / (4 * alpha * F) * np.log( f_j*(4*F*D_eff_O2N2*p_atm/(t_C*R*T)) /(j0*10000*(1-f_j)))

            # This is the formula from the book, but it didn't work as expected.
            # Implemented a re-derived version instead that is much better
            # eta_cathode = R * T / (4 * alpha * F) * np.log( j / ( j0 * p ) * (1 / (x_O2d - t_C * ((j*10000 * R * T)/(4 * F * p_atm * D_eff_O2N2)))) )
            
            V = E_thermo - eta_ohmic - max([eta_cathode,0])
            
            n_H2 = 2  # H2 reaction rejects 2 electrons
            n_O2 = 4  # O2 reaction accepts 4 electrons
            
            molarMass_H2 = 2.016
            molarMass_O2 = 15.999
            massFraction_O2inAir = .2313333 # air is 23% oxygen by mass

            J_H2 = j/(n_H2*F)  # mol/s
            mdot_H2 = J_H2*molarMass_H2 # g/s
            
            J_O2 = j/(n_O2*F)  # mol/s
            mdot_O2 = J_O2*molarMass_O2 # g/s
            
            mdot_Air = mdot_O2/massFraction_O2inAir 
            
            eps_voltage = V/E_thermo
            eps_fuel = 1.0 # Assume for aircraft no fuel will be wasted, recycling injector?
            eps_total = eps_thermo * eps_voltage * eps_fuel
            
            powerRate = V*j
            powerRate_ideal = powerRate/eps_total
            heatRate = powerRate_ideal - powerRate
            
            if powerRate_prev < powerRate:
                j_max = j
                powerRate_prev = powerRate
        
        outputs['j_max'] = j_max

class SOFCSizing(ExplicitComponent):
    """
    This is a model for sizing SOFC fuel cells based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016).   

    Inputs
    ------
    j_max : float
        Current density that maximizes power output
        (scalar, A/cm**2)
    pressure : float
        Ambient pressure
        (scalar, atmospheres)
    temperature : float
        Ambient temperature
        (scalar, Kelvin)
    diffusivity_O2N2 : float
        Binary diffusion coefficient for oxygen and nitrogen, comes from previous model
        (scalar, m**2/s)
    eps_thermo : float
        Max theoretical efficiency of the fuel cell, comes from previous model
        (scalar, dimensionless)

    Outputs
    -------
    mass : float
        Mass prediction for the entire fuel cell system, including balance of plant but NOT including a compressor.
        (scalar, kg)
    area : float
        Working area of the fuel cell
        (scalar, m**2)

    Options
    -------
    n_samples : int
        Number of samples used in finding the j_max value
        (default 1000)
    j_L : float
        Limit current density, primarily driven by the thickness of the cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)
    t_M : float
        Membrane thickness for the electrolyte passing material [m]
        (default 20e-6)
    A_SOFC : float
        Electrolyte constant, essentially the resistivity of the electrolyte material [K/(ohm*m)]
        (default  9e7)
    E_thermo     
        Thermodynamic voltage, theoretical value that probably should not change [V]
        ( default 1.06 )     
    DeltaG_act   
        Electrolyte activation energy [J/mol]
        ( default 100e3 )    
    alpha        
        Transfer coefficient, ranges from 0.2 to 0.5
        ( default 0.5 )      
    j0           
        Exchange current density [A/cm**2]
        ( default 0.1 )      
    eps          
        Porosity of the electrodes
        ( default 0.4 )      
    tau          
        Tortuosity of the electrodes, ranges from 1.5 to 10
        ( default 1.5 )      
    R            
        Gas constant [J/(mol*K)]
        ( default 8.314 )    
    F            
        Faraday constant [C/mol]
        ( default 96485.34 ) 
    x_O2d        
        Oxygen inlet mole fraction
        ( default 0.21 )    

    """

    def initialize(self):
        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # Likely to change:
        self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        self.options.declare("A_SOFC"      , default = 9e7       , desc = "Electrolyte constant [K/(ohm*m)]")
        
        # May Change:
        self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        self.options.declare("DeltaG_act"  , default = 100e3     , desc = "Electrolyte activation energy [J/mol]")
        self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # Should not change
        self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        self.options.declare("x_O2d"       , default = 0.21      , desc = "Oxygen inlet mole fraction")


    def setup(self):
        self.add_input("ratedPower"       , units="W"       , desc = "Rated Power")
        self.add_input("j_max"            , units="A/cm**2" , desc = "Fuel cell current density")
        self.add_input("pressure"         , units="atm"     , desc = "Fuel cell pressure")
        self.add_input("temperature"      , units="K"       , desc = "Fuel cell temperature")
        self.add_input("diffusivity_O2N2" , units="m**2/s"  , desc = "Diffusivity of oxygen and nitrogen")
        self.add_input("eps_thermo"       ,                   desc = "Max theoretical thermo efficiency")

        self.add_output('mass', units = "kg"   , desc = "Fuel cell mass")
        self.add_output('area', units = "m**2" , desc = "Fuel cell area")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        j_max      = inputs["j_max"]
        p          = inputs["pressure"]
        T          = inputs["temperature"]
        D_ij       = inputs["diffusivity_O2N2"]
        eps_thermo = inputs["eps_thermo"]
        ratedPower = inputs["ratedPower"]

        j_L        = self.options["j_L"]
        t_M        = self.options["t_M"]
        A_SOFC     = self.options["A_SOFC"]
        E_thermo   = self.options["E_thermo"]
        DeltaG_act = self.options["DeltaG_act"]
        alpha      = self.options["alpha"]
        j0         = self.options["j0"]
        eps        = self.options["eps"]
        tau        = self.options["tau"]
        R          = self.options["R"]
        F          = self.options["F"]
        x_O2d      = self.options["x_O2d"]
        eta_dcdc   = self.options["eta_dcdc"]
        A          = self.options["A"]
        B          = self.options["B"]
        
        j = j_max

        eta_ohmic = j * 1e4 * (t_M * T) / (A_SOFC * np.exp(-DeltaG_act / (R*T)))

        p_atm = 101325   # Atmospheric pressure in Pa
        p_c = p * p_atm  # Convert cathode pressure to Pa

        D_eff_O2N2 = eps / tau * D_ij
        cr = x_O2d*p_c/ R/T
        t_C = 4 * F * D_eff_O2N2 / j_L * cr/10000
        f_j = j/j_L
        if j == 0:
            eta_cathode = 0
        elif f_j>=1:
            eta_cathode = E_thermo
        else:
            eta_cathode =  R * T / (4 * alpha * F) * np.log( f_j*(4*F*D_eff_O2N2*p_atm/(t_C*R*T)) /(j0*10000*(1-f_j)))
        
        # This is the formula from the book, but it didn't work as expected.
        # Implemented a re-derived version instead that is much better
        # eta_cathode = R * T / (4 * alpha * F) * np.log( j / ( j0 * p ) * (1 / (x_O2d - t_C * ((j*10000 * R * T)/(4 * F * p_atm * D_eff_O2N2)))) )

        V = E_thermo - eta_ohmic - max([eta_cathode,0])

        n_H2 = 2  # H2 reaction rejects 2 electrons
        n_O2 = 4  # O2 reaction accepts 4 electrons
        
        molarMass_H2 = 2.016
        molarMass_O2 = 15.999
        massFraction_O2inAir = .2313333 # air is 23% oxygen by mass

        J_H2 = j/(n_H2*F)  # mol/s
        mdot_H2 = J_H2*molarMass_H2 # g/s
        
        J_O2 = j/(n_O2*F)  # mol/s
        mdot_O2 = J_O2*molarMass_O2 # g/s
        
        mdot_Air = mdot_O2/massFraction_O2inAir         

        eps_voltage = V/E_thermo
        eps_fuel = 1.0 # Assume for aircraft no fuel will be wasted, recycling injector?
        eps_total = eps_thermo * eps_voltage * eps_fuel
        
        powerRate = V*j
        powerRate_ideal = powerRate/eps_total
        heatRate = powerRate_ideal - powerRate

        area = ratedPower / eta_dcdc / (V*j_max) / 10000
        usablePower = powerRate * area *10000 * eta_dcdc
        mass = A*area + B*usablePower/1000
        outputs['mass'] = mass
        outputs['area'] = area

class SOFCAnalysis(ExplicitComponent):
    """
    This is a model for analysis of SOFC fuel cells based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016).   


    Inputs
    ------
    pressure : float
        Operating pressure of the fuel cell.  This model does not account
        for a compressor to rais the operating pressure from ambient.
        (scalar, atmospheres)
    temperature : float
        Operating temperature of the fuel cell.
        (scalar, Kelvin)
    ratedPower : float
        Rated power of the fuel cell after DC-DC conversion
        (scalar, W)
    throttle : float
        Engine throttle. Scales current density based on the internally 
        computed maximum current density value.  Produces 100% of rated 
        power at throttle = 1.  Should be in range 0 to 1
        (vector, dimensionless)
    j_max : float
        Current density that maximizes power output
        (scalar, A/cm**2)
    diffusivity_O2N2 : float
        Binary diffusion coefficient for oxygen and nitrogen, comes from previous model
        (scalar, m**2/s)
    eps_thermo : float
        Max theoretical efficiency of the fuel cell, comes from previous model
        (scalar, dimensionless)
    area : float
        Working area of the fuel cell
        (scalar, m**2)

    Outputs
    -------
    mdot_H2 : float
        Mass consumption of hydrogen, ie fuel flow
        (vector, kg/s)
    mdot_O2 : float
        Mass consumption of oxygen, sets inlet requirements
        (vector, kg/s)
    mdot_Air : float
        Mass consumption of air based on the mass fraction of oxygen
        (vector, kg/s) 
    eps_total : float
        Fuel cell efficiency
        (vector, dimensionless)
    power : float
        Electrical power generated by the fuel cell
        (vector, Watts)
    usablePower : float
        Power available after DC-DC conversion
        (vector, Watts)
    usableHeat : float
        Heat generated by the fuel cell and the DC-DC converter
        (vector, Watts)
    heat : float
        Heat generated by the fuel cell 
        (vector, Watts)

    Options
    -------
    num_nodes : int
        Number of analysis points to run (sets vec length; default 1)
    j_L : float
        Limit current density, primarily driven by the thickness of the cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)
    t_M : float
        Membrane thickness for the electrolyte passing material [m]
        (default 20e-6)
    A_SOFC : float
        Electrolyte constant, essentially the resistivity of the electrolyte material [K/(ohm*m)]
        (default  9e7)
    E_thermo     
        Thermodynamic voltage, theoretical value that probably should not change [V]
        ( default 1.06 )     
    DeltaG_act   
        Electrolyte activation energy [J/mol]
        ( default 100e3 )    
    alpha        
        Transfer coefficient, ranges from 0.2 to 0.5
        ( default 0.5 )      
    j0           
        Exchange current density [A/cm**2]
        ( default 0.1 )      
    eps          
        Porosity of the electrodes
        ( default 0.4 )      
    tau          
        Tortuosity of the electrodes, ranges from 1.5 to 10
        ( default 1.5 )      
    R            
        Gas constant [J/(mol*K)]
        ( default 8.314 )    
    F            
        Faraday constant [C/mol]
        ( default 96485.34 ) 
    x_O2d        
        Oxygen inlet mole fraction
        ( default 0.21 )    

    """

    def initialize(self):
        self.options.declare("num_nodes", default=1, desc = "Number of flight/control conditions")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # Likely to change:
        self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        self.options.declare("A_SOFC"      , default = 9e7       , desc = "Electrolyte constant [K/(ohm*m)]")
        
        # May Change:
        self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        self.options.declare("DeltaG_act"  , default = 100e3     , desc = "Electrolyte activation energy [J/mol]")
        self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # Should not change
        self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        self.options.declare("x_O2d"       , default = 0.21      , desc = "Oxygen inlet mole fraction")

    def setup(self):
        nn = self.options["num_nodes"]
        self.add_input("ratedPower"       , units="W"       , desc = "Rated Power")
        self.add_input("throttle"         ,                   desc = "Throttle input (Fractional)", shape=(nn,))
        self.add_input("j_max"            , units="A/cm**2" , desc = "Fuel cell current density")
        self.add_input("pressure"         , units="atm"     , desc = "Fuel cell pressure")
        self.add_input("temperature"      , units="K"       , desc = "Fuel cell temperature")
        self.add_input("diffusivity_O2N2" , units="m**2/s"  , desc = "Diffusivity of oxygen and nitrogen")
        self.add_input("eps_thermo"       ,                   desc = "Max theoretical thermo efficiency")
        self.add_input('area'             , units = "m**2"  , desc = "Fuel cell voltage")

        self.add_output('mdot_H2'     , units = "kg/s" , desc = "Mass consumption of hydrogen"                            , shape=(nn,))
        self.add_output('mdot_O2'     , units = "kg/s" , desc = "Mass consumption of oxygen"                              , shape=(nn,))
        self.add_output('mdot_Air'    , units = "kg/s" , desc = "Mass consumption of air"                                 , shape=(nn,))
        self.add_output('eps_total'   ,                  desc = "Total fuel cell efficiency"                              , shape=(nn,))
        self.add_output('power'       , units = "W"    , desc = "Electrical power generated by the fuel cell"             , shape=(nn,))
        self.add_output('usablePower' , units = "W"    , desc = "Power available after DC-DC conversion"                  , shape=(nn,))
        self.add_output('usableHeat'  , units = "W"    , desc = "Heat generated by the fuel cell and the DC-DC converter" , shape=(nn,))
        self.add_output('heat'        , units = "W"    , desc = "Heat generated by the fuel cell"                         , shape=(nn,))

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        throttle   = inputs["throttle"]
        j_max      = inputs["j_max"]
        p          = inputs["pressure"]
        T          = inputs["temperature"]
        D_ij       = inputs["diffusivity_O2N2"]
        eps_thermo = inputs["eps_thermo"]
        ratedPower = inputs["ratedPower"]
        area       = inputs["area"]

        j_L        = self.options["j_L"]
        t_M        = self.options["t_M"]
        A_SOFC     = self.options["A_SOFC"]
        E_thermo   = self.options["E_thermo"]
        DeltaG_act = self.options["DeltaG_act"]
        alpha      = self.options["alpha"]
        j0         = self.options["j0"]
        eps        = self.options["eps"]
        tau        = self.options["tau"]
        R          = self.options["R"]
        F          = self.options["F"]
        x_O2d      = self.options["x_O2d"]
        eta_dcdc   = self.options["eta_dcdc"]
        A          = self.options["A"]
        B          = self.options["B"]

        j = throttle * j_max

        eta_ohmic = j * 1e4 * (t_M * T) / (A_SOFC * np.exp(-DeltaG_act / (R*T)))

        p_atm = 101325   # Atmospheric pressure in Pa
        p_c = p * p_atm  # Convert cathode pressure to Pa

        D_eff_O2N2 = eps / tau * D_ij
        cr = x_O2d*p_c/ R/T
        t_C = 4 * F * D_eff_O2N2 / j_L * cr/10000
        V = np.zeros(len(j),dtype=np.complex_)
        for i in range(0,len(j)):
            jval = j[i]
            f_j = jval/j_L
            if jval == 0:
                eta_cathode = 0
            elif f_j>=1:
                eta_cathode = E_thermo
            else:
                eta_cathode =  R * T / (4 * alpha * F) * np.log( f_j*(4*F*D_eff_O2N2*p_atm/(t_C*R*T)) /(j0*10000*(1-f_j)))

            # This is the formula from the book, but it didn't work as expected.
            # Implemented a re-derived version instead that is much better
            # eta_cathode = R * T / (4 * alpha * F) * np.log( j / ( j0 * p ) * (1 / (x_O2d - t_C * ((j*10000 * R * T)/(4 * F * p_atm * D_eff_O2N2)))) )
            
            # print(E_thermo - eta_ohmic[i] - max([eta_cathode,0]))
            # print("=========================")
            V[i] = E_thermo - eta_ohmic[i] - max([eta_cathode,0])
        
        n_H2 = 2  # H2 reaction rejects 2 electrons
        n_O2 = 4  # O2 reaction accepts 4 electrons
        
        molarMass_H2 = 2.016
        molarMass_O2 = 15.999
        massFraction_O2inAir = .2313333 # air is 23% oxygen by mass

        J_H2 = j/(n_H2*F)  # mol/s
        mdot_H2 = J_H2*molarMass_H2 # g/s
        
        J_O2 = j/(n_O2*F)  # mol/s
        mdot_O2 = J_O2*molarMass_O2 # g/s
        
        mdot_Air = mdot_O2/massFraction_O2inAir         
        
        eps_voltage = V/E_thermo
        eps_fuel = 1.0 # Assume for aircraft no fuel will be wasted, recycling injector?
        eps_total = eps_thermo * eps_voltage * eps_fuel
        
        powerRate = V*j
        powerRate_ideal = powerRate/eps_total
        heatRate = powerRate_ideal - powerRate

        # must convert the j values to m**2 and not cm**2
        outputs['mdot_H2']       = mdot_H2   * area * 10000
        outputs['mdot_O2']       = mdot_O2   * area * 10000
        outputs['mdot_Air']      = mdot_Air  * area * 10000
        outputs['eps_total']     = eps_total * eta_dcdc
        outputs['power']         = powerRate * area * 10000
        outputs['usablePower']   = powerRate * area * 10000 * eta_dcdc
        outputs['heat']          = heatRate  * area * 10000
        outputs['usableHeat']    = heatRate  * area * 10000 + (1-eta_dcdc) * powerRate * area * 10000
    
